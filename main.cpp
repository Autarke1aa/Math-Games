#include <iostream>
#include <vector>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    cout <<"   Игра № 1(Игра Баше) . Правила игры: На кону 100 камешков, два игрока по очереди берут от 1 до 10 камней. Выигрывает тот, кто возьмёт последний камень."<< endl;
    cout<< "   Игра № 2(Конфетки). Правила игры : На столе лежит 30 конфет. Два игрока ходят по очереди. Играют по следуюшим правилам: если сейчас n-й по счету ход, то ходящий в данный момент игрок может съесть от одной до n конфет. Проигрывает съевший последнею конфету."<<endl;
    cout<< "   Игра № 3(Ним). Правила игры : Ним — игра, в которой два игрока по очереди берут предметы, разложенные на несколько кучек (в нашем случае 4 кучки по : 1, 3, 5 и 7 предметам). За один ход может быть взято любое количество предметов (больше нуля) из одной кучки. Игрок взявший последний предмет проигрывает." << endl;
    cout<<endl<<"Введите номер игры, которую хотите опробовать."<<endl;
    int k;
    cin >> k;
    while(k!=1 && k!=2 && k!=3){
        cout<<"Игры с таким номером не существует, попробуйте снова."<<endl;
        int k1;
        cin >> k1;
        k=k1;
    }

    if(k==1){
        cout<<endl<<endl<<endl;
        cout<<"          Игра Баше"<<endl;
        int sum=0;
    cout << "Сумма = 0" <<endl;
    cout<<"Введите 1 чтобы играть первым и 2 иначе."<<endl;
    int tag;
    cin>>tag;
    if(tag == 2){
        sum++;
        cout<<"Новая сумма = 1"<<endl;
    }
    int flag;
    while(sum<100){
        int number,q=0;
        while(q==0){
        cin >> number;
        if(number<1 || number>10){
            cout<<"Этот ход не разрешен, попробуйте снова."<<endl;
        }
        else{
            q=1;
        }
        }
        sum+=number;
        cout<<"Новая сумма = " <<sum<<endl;
        flag=0;
        if(sum>=100){
            break;
        }
        if(sum%11==0){
            sum+=1;
            cout<<"Новая сумма = "<<sum<<endl;
        }
        else if((sum%11)==1){
            sum+=10;
            cout<<"Новая сумма = "<<sum<<endl;
            flag=1;
        }
        else{
            sum+=(12-sum%11 );
            cout<<"Новая сумма = "<<sum<<endl;
            flag=1;
        }
    }
    if(flag==0){
        cout<<"Вы выйграли!!!";
    }
    else{
        cout<<"Вы проиграли...";
    }
    cout<<endl<<endl<<"Введите любое число, если хотите узнать выйгрышную стратегию."<<endl;
    int k2;
    cin>>k2;
    cout<<"Решение: Первый игрок должен убедится, что сумма после каждого эго хода равна: 1,12,23,34,45,56,67,78,89,100 соответсвенно.";
    }

    else if(k==2){
        cout<<endl<<endl<<endl;
        cout<<"                    КОНФЕТКИ"<<endl;
        int sum=30,q=0;
    cout<<"Введите 1 чтобы играть первым и 2 иначе."<<endl;
    int tag;
    cin>>tag;
    if(tag==2){
        q++;
        sum-=1;
        cout<<"Количество конфет после хода после хода № "<<q<<" = "<<sum<<endl;
    }
    while(sum>0){
        int number,t=0;
        while(t==0){
        cin >> number;
        if(number>q+1 || number<=0 || sum-number<0){
            cout<<"Этот ход не разрешен, попробуйте снова."<<endl;
        }
        else{
            t=1;
        }
        }
        q++;
        sum-=number;
        cout<<"Количество конфет после хода после хода № "<<q<<" = "<<sum<<endl;
        if(sum==0){
            cout<<"Вы проиграли...";
            break;
        }
        q++;
        if(sum-25<=q && sum-25>0){
            sum-=(sum-25);
            cout<<"Количество конфет после хода после хода № "<<q<<" = "<<sum<<endl;
        }
        else if(sum-19<=q && sum-19>0){
            sum-=(sum-19);
            cout<<"Количество конфет после хода после хода № "<<q<<" = "<<sum<<endl;
        }
        else if(sum-11<=q && sum-11>0){
            sum-=(sum-11);
            cout<<"Количество конфет после хода после хода № "<<q<<" = "<<sum<<endl;
        }
        else if(sum-1<=q && sum-1>0){
            sum-=(sum-1);
            cout<<"Количество конфет после хода после хода № "<<q<<" = "<<sum<<endl;
        }
        else{
            sum-=1;
            cout<<"Количество конфет после хода после хода № "<<q<<" = "<<sum<<endl;
        }
        if(sum==0){
            cout<<"Вы выйграли!!!";
        }
    }
    cout<<endl<<endl<<"Введите любое число, если хотите узнать выйгрышную стратегию."<<endl;
    int k2;
    cin >> k2;
    cout<< "Решение : Убедитесь, что первый игрок выигрывает если на столе лежат: 5, 11 или 19 конфет.";
    }

    else if(k==3){
        cout<<endl<<endl<<endl;
        cout<<"                       НИМ" << endl;
        vector <int> p {0,1,3,5,7};
    vector <int> a(5);
    vector <int> b(5);
    vector <int> c(5);
    int flag;
    cout<<"Введите 1 чтобы играть первым и 2 иначе."<<endl;
    cin >>  flag;
    cout << "Кучка № 1" << endl;
    cout << "Кучка № 3" << endl;
    cout << "Кучка № 5" << endl;
    cout << "Кучка № 7" << endl<<endl;
    if(flag == 1){
       int np,n,harosh=1;
       cout<<"Сделайте ход"<<endl;
       cin >>np >> n;
       while (harosh==1){
       if((np>4 || np<1) || (n>p[np] || n<1)){
        cout<<"Этот ход не разрешен, попробуйте снова."<<endl;
        int nr,r;
        cin>>nr>>r;
        if(nr<5 && nr>0 && r<=p[nr] && r>0){
            harosh=0;
            np=nr;
            n=r;
        }
       }
       else{
        harosh=0;
       }
       }
       p[np]-=n;
       cout<<"Кучка № 1: "<<p[1]<<endl;
       cout<<"Кучка № 2: "<<p[2]<<endl;
       cout<<"Кучка № 3: "<<p[3]<<endl;
       cout<<"Кучка № 4: "<<p[4]<<endl<<endl;
    }
    while (p[1]>0 || p[2]>0 || p[3]>0 || p[4]>0){
        a[1]=(p[1]-p[1]%4)/4 , b[1]=(p[1]-a[1]*4-(p[1]-a[1]*4)%2)/2 , c[1]=p[1]%2;
        a[2]=(p[2]-p[2]%4)/4 , b[2]=(p[2]-a[2]*4-(p[2]-a[2]*4)%2)/2 , c[2]=p[2]%2;
        a[3]=(p[3]-p[3]%4)/4 , b[3]=(p[3]-a[3]*4-(p[3]-a[3]*4)%2)/2 , c[3]=p[3]%2;
        a[4]=(p[4]-p[4]%4)/4 , b[4]=(p[4]-a[4]*4-(p[4]-a[4]*4)%2)/2 , c[4]=p[4]%2;
        if((p[2]+p[4]+p[3]==1 && p[1]>1) || (p[1]+p[2]+p[3]==1 && p[4]>1) || (p[1]+p[2]+p[4]==1 && p[3]>1) || (p[1]+p[3]+p[4]==1 && p[2]>1)){
            for(int i=1; i<5; i++){
                if(p[i]>1){
                    p[i]=0;
                }
            }
        }
        else if((p[2]+p[4]+p[3]==0 && p[1]>1) || (p[1]+p[2]+p[3]==0 && p[4]>1)|| (p[1]+p[2]+p[4]==0 && p[3]>1)|| (p[1]+p[3]+p[4]==0 && p[2]>1)){
            for(int i=1; i<5; i++){
                if(p[i]>0){
                    p[i]=1;
                }
            }
        }
        else if((a[1]+a[2]+a[3]+a[4])%2==0 && (b[1]+b[2]+b[3]+b[4])%2==0 && (c[1]+c[2]+c[3]+c[4])%2==0){
              if(p[1]!=0){
                p[1]-=1;
              }
              else if(p[2]!=0){
                p[2]-=1;
              }
              else if(p[3]!=0){
                p[3]-=1;
              }
              else if(p[4]!=0){
                p[4]-=1;
              }
        }
        else if(((p[1]+p[2]==0) && p[3]>0 && p[4]>0) || ((p[1]+p[3]==0) && p[2]>0 && p[4]>0) || ((p[1]+p[4]==0) && p[2]>0 && p[3]>0) || ((p[2]+p[3]==0) && p[1]>0 && p[4]>0) || ((p[2]+p[4]==0) && p[1]>0 && p[3]>0) || ((p[4]+p[3]==0) && p[2]>0 && p[1]>0)){
            for(int i=1; i<5; i++){
                for(int j=1; j<5; j++){
                    if(p[j]!=0 && p[i]>p[j]){
                        p[i]=p[j];
                    }
                }
            }
        }

       else{
           int i=1,flag=0;
           while(flag==0) {
               int s1=(a[1]+a[2]+a[3]+a[4]-a[i])%2;
               int s2=(b[1]+b[2]+b[3]+b[4]-b[i])%2;
               int s3=(c[1]+c[2]+c[3]+c[4]-c[i])%2;
               int jivuci=s1*4 + s2*2 + s3;
               if(p[i]>jivuci){
                   if(jivuci==0 && p[1]+p[2]+p[3]+p[4]-p[i]==2 && p[i]>1){
                    p[i]=1;
                   }
                   else if(jivuci==1 && p[1]+p[2]+p[3]+p[4]-p[i]==3){
                    p[i]=0;
                   }
                   else{
                       p[i]=jivuci;;
                   }
                   flag=1;
               }
               else{
                   i++;
               }
           }
       }

        cout<<"Компютер сделал ход"<<endl;
              cout<<"Кучка № 1: "<<p[1]<<endl;
              cout<<"Кучка № 2: "<<p[2]<<endl;
              cout<<"Кучка № 3: "<<p[3]<<endl;
              cout<<"Кучка № 4: "<<p[4]<<endl<<endl;
              if(p[1]==0 && p[2]==0 && p[3]==0 && p[4]==0){
                cout<<"Вы выйграли!!!";
                break;
              }

       int np,n;
       cin >>np >> n;
       while((np>4 || np<1) || (n>p[np] || n<1)){
        cout<<"Этот ход не разрешен, попробуйте снова."<<endl;
        int nr,r;
        cin>>nr>>r;
        np=nr;
        n=r;
       }
       p[np]-=n;
       cout<<"Кучка № 1: "<<p[1]<<endl;
       cout<<"Кучка № 2: "<<p[2]<<endl;
       cout<<"Кучка № 3: "<<p[3]<<endl;
       cout<<"Кучка № 4: "<<p[4]<<endl<<endl;
       if(p[1]==0 && p[2]==0 && p[3]==0 && p[4]==0){
                cout<<"Вы проиграли...";
       }
    }
    cout<<endl<<endl<<"Введите любое число, если хотите узнать выйгрышную стратегию."<<endl;
    int k2;
    cin >> k2;
    cout<<"      Решение:"<<endl;
    cout<<"   Каждой позиции игры ставится в соответствие ним-сумма этой позиции — результат сложения размеров всех кучек в двоичной системе счисления без учёта переноса разрядов, то есть ним-сумма данной позиции это число n-ая цифра в двоичной записи которого равна, сумме n-ых цифр в двоичной записи размеров всех кучек, по модулю 2. "<<endl;
    cout<<"   Выигрышная стратегия состоит в том, чтобы оставлять после своего хода позицию с ним-суммой, равной нулю. Она основана на том, что из любой позиции с ним-суммой, не равной нулю, можно одним ходом получить позицию с нулевой ним-суммой, а из позиции с нулевой ним-суммой любой ход ведёт в позицию с ним-суммой, отличной от нуля."<<endl;
    cout<<"   То ,что из позиции с нулевой ним-суммой любой ход ведёт в позицию с ним-суммой, отличной от нуля очевидно ( т. к. при этом ходе изменится хотя бы одна цифра в двоичной записи ровно одного размера кучки, а значит хотя бы одна цифра в двоиной запиcи ним-суммы станет равна 1). Докажем, что из любой позиции с ним-суммой, не равной нулю, можно одним ходом получить позицию с нулевой ним-суммой. Пусть: i-ая цифра ним-суммы в двоичной записи это первая цифра с лева которая равна 1. Тогда, рассмотрим кучку размер которой равен числу А, i-ая цифра в двоичной записи которого равна 1 (она существует, т. к. в противном случае i-я цифра ним-суммы в двоичной записи будет равна 0). Теперь выберем такое число B, что, в двоичной записи, эго i-ая цифра равна нулю, все цифры слева совпадают с цифрами числа А, а все цифры справа подобраны таким образом, что ним-сумма позиции, в которой вместо кучки с размером А стоит кучка с размером В, равна 0. Число В меньше чем А, значит мы можем эго получить путём вычета ненулевого количества предметов из кучки с размером А."<<endl;
    }
    cout<<"   Заметим, что позиция, в которой предметы остались только в двух кучках одинакового размера больше 1, проигрышна ( это несложно доказать по индукции). При этом ним-сумма жтой позиции равна 0, значит она достижима с помощью нащей стратегии. В нашем случае где 4 кучки по : 1, 3, 5 и 7 предметам ним-сумма стартовой позийии равна нулю, значит второй игок выигрывает при правильной игре."<<endl;
}

